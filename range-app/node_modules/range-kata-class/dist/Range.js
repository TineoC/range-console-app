import { inRange } from './InRange.js';
export default class Range {
    input;
    lower;
    higher;
    constructor(input) {
        this.input = input;
        const invalidRangeRegExp = /^(\[|\()\s*(\-)?\d+\s*,\s*(\-)?\d+(\]|\))$/;
        const invalidSeparatorRegExp = /^(\[|\()\s*\d+\s*(,{2,}|[^,])\s*\d+(\]|\))$/;
        const validRange = invalidRangeRegExp.test(input);
        const invalidSeparator = invalidSeparatorRegExp.test(input);
        let lowerGreaterThanHigher = false;
        if (validRange) {
            const first = parseInt(input.substring(1, input.indexOf(',')));
            const second = parseInt(input.substring(input.indexOf(',') + 1, input.length));
            this.lower = { value: first, closed: input[0] == '[' };
            this.higher = { value: second, closed: input[input.length - 1] == ']' };
            lowerGreaterThanHigher = this.lower.value > this.higher.value;
        }
        if (invalidSeparator) {
            throw Error('Invalid Separator');
        }
        else if (!validRange || lowerGreaterThanHigher) {
            throw Error('Invalid Range');
        }
    }
    contains(list) {
        if (list.length === 0)
            return false;
        list = [...new Set(list)]; // Remove duplicate points from input
        for (const number of list) {
            const lowerEndPoint = this.endPoints()[0];
            const higherEndPoint = this.endPoints()[1];
            if (!inRange(number, lowerEndPoint, higherEndPoint)) {
                return false;
            }
        }
        return true;
    }
    containsRange(range) {
        const lowerEndPoint = range.endPoints()[0];
        const higherEndPoint = range.endPoints()[1];
        if (this.lower.value < lowerEndPoint && this.higher.value > higherEndPoint) {
            return true;
        }
        return false;
    }
    endPoints() {
        let endPointsArray = [];
        const lowerEndpoint = this.lower;
        const higherEndpoint = this.higher;
        if (lowerEndpoint.value === higherEndpoint.value)
            return endPointsArray;
        if (this.lower.closed) {
            endPointsArray.push(lowerEndpoint.value);
        }
        else {
            endPointsArray.push(lowerEndpoint.value + 1);
        }
        if (this.higher.closed) {
            endPointsArray.push(higherEndpoint.value);
        }
        else {
            endPointsArray.push(higherEndpoint.value - 1);
        }
        return endPointsArray;
    }
    overlaps(range) {
        const lowerEndPoint = range.endPoints()[0];
        const higherEndPoint = range.endPoints()[1];
        if (this.lower.value <= higherEndPoint && lowerEndPoint <= this.higher.value) {
            return true;
        }
        return false;
    }
    equals(range) {
        const rangeAEndpoints = this.endPoints();
        const rangeBEndpoints = range.endPoints();
        return JSON.stringify(rangeAEndpoints) === JSON.stringify(rangeBEndpoints);
    }
    allPoints() {
        let points = [];
        if (!this.endPoints())
            return points;
        const start = this.endPoints()[0];
        const limit = this.endPoints()[1];
        let index = start;
        while (index <= limit) {
            points.push(index);
            index++;
        }
        return points;
    }
}
